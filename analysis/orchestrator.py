# analysis/orchestrator.py

# This script acts as the "brain" of the analysis phase.
# It orchestrates the entire workflow by calling the necessary functions and classes
# from other modules in the correct order.

# --- Imports ---

# `numpy` is a fundamental library for numerical computing in Python. It's often a dependency of other data science libraries.
import numpy as np
# `pathlib` provides an object-oriented way to work with filesystem paths, which is often easier and more readable than using strings.
from pathlib import Path
# Import `List` and `Dict` for type hinting, making the code clearer.
from typing import List, Dict

# Import our project's configuration.
import config
# Import the `MalwareSearch` class, which is responsible for querying the vector database.
from retrieval.search import MalwareSearch
# Import the feature extraction function.
from ingestion.preprocessing import extract_code_features
# Import the other modules from the `analysis` package.
from analysis import query_router, yara_generator, llm_analyzer

# --- The Main Analyzer Class ---

# In Python, it's common to group related methods (functions) and data into a class.
# This class will manage the entire analysis process.
class ComprehensiveMalwareAnalyzer:
    """Orchestrates the full malware analysis workflow."""

    # The `__init__` method is a special method called a "constructor".
    # It's executed automatically when you create a new instance of the class (e.g., `analyzer = ComprehensiveMalwareAnalyzer(...)`).
    # `self` refers to the instance of the class itself, allowing you to store data on it.
    def __init__(self, search_engine: MalwareSearch):
        # We store the passed-in `search_engine` object as an attribute of the instance.
        # This makes it accessible to other methods in the class, like `self.search_engine`.
        self.search_engine = search_engine

    # This is the main method that performs the end-to-end analysis.
    # `include_yara: bool = True` is a parameter with a default value. The caller can override it if they want.
    def full_analysis_report(self, suspicious_code: str, include_yara: bool = True) -> str:
        """Generate a comprehensive analysis report."""
        # Print status messages to the console to let the user know what's happening.
        print("[*] Starting comprehensive malware analysis...")

        # Step 1: Route the query to determine a broad malware category.
        malware_type = query_router.route_query(suspicious_code)
        print(f"[+] Detected malware type: {malware_type}")

        # Step 2: Search the vector database for similar malware samples.
        print("[*] Searching for similar malware samples...")
        # We call the `hybrid_search` method on the search engine object we stored earlier.
        similar_samples = self.search_engine.hybrid_search(suspicious_code, top_k=10)

        # Step 3: Extract key features (IOCs) from the user's suspicious code.
        print("[*] Extracting indicators of compromise...")
        features = extract_code_features(suspicious_code)

        # Step 4: Optionally, generate a YARA rule.
        # Initialize an empty string for the YARA rule.
        yara_rule = ""
        # The `and` operator checks both conditions. We only generate a rule if the user wants one
        # AND we found at least 2 similar samples (to ensure the rule is based on a pattern).
        if include_yara and len(similar_samples) >= 2:
            print("[*] Generating YARA detection rule...")
            # Call the function from the yara_generator module.
            yara_rule = yara_generator.generate_yara_rule(malware_type, similar_samples)

        # Step 5: Build the rich context prompt for the LLM.
        print("[*] Building context for LLM...")
        context = llm_analyzer.build_analysis_context(similar_samples, features)
        
        # If a YARA rule was generated, append it to the context string.
        if yara_rule:
            # `+=` is a shorthand for `context = context + ...`
            context += f"\n## Auto-Generated YARA Rule\n```yara\n{yara_rule}\n```"

        # Step 6: Send the code and context to the LLM for the final analysis.
        print("[*] Generating detailed analysis with LLM...")
        analysis = llm_analyzer.analyze_with_llm(suspicious_code, context)

        # Step 7: Return the final report generated by the LLM.
        return analysis

    # This is a second method in the class for analyzing multiple files in a batch.
    def batch_analysis(self, code_samples: List[str], output_dir: str = "./analysis_reports"):
        """Analyze multiple samples and save reports."""
        # Create a Path object for the output directory.
        output_path = Path(output_dir)
        # `mkdir` creates the directory. `exist_ok=True` prevents an error if the directory already exists.
        output_path.mkdir(exist_ok=True)

        # Loop through the provided list of code samples.
        for i, code in enumerate(code_samples, 1):
            print(f"\n{'='*60}\nAnalyzing sample {i}/{len(code_samples)}\n{'='*60}")
            # Use a try...except block to ensure that if one sample fails, the whole batch process doesn't stop.
            try:
                # Call the main analysis function for the current code sample.
                report = self.full_analysis_report(code)
                # Create a unique filename for the report.
                # `output_path / ...` is a clean way to join path components using pathlib.
                # `hash(code) & 0xFFFF:04x` creates a short, hexadecimal hash of the code to make the filename unique.
                report_file = output_path / f"report_{i}_{hash(code) & 0xFFFF:04x}.md"
                # `with open(...)` safely opens the file for writing ('w').
                with open(report_file, 'w', encoding='utf-8') as f:
                    # Write the report content to the file.
                    f.write(f"# Malware Analysis Report - Sample {i}\n\n")
                    f.write(report)
                print(f"[+] Report saved to: {report_file}")
            # Catch any potential error during the analysis of a single file.
            except Exception as e:
                print(f"[!] Error analyzing sample {i}: {e}")